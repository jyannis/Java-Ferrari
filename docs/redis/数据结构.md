Redis有五大数据结构。

**目录**

- [字符串String](#字符串String)
- [哈希Hash](#哈希Hash)
- [列表List](#列表List)
- [集合Set](#集合Set)
- [有序集合Zset](#有序集合Zset)

<br/>

<br/>

## 字符串String

#### 内部编码

字符串类型的内部编码有三种：

- int：8个字节的长整型
- embstr：小于等于39个字节的字符串
- raw：大于39个字节的字符串

Redis根据当前值的类型和长度决定使用哪种编码实现。

<br/>

#### 使用场景

1. 缓存
2. 计数
3. 多应用服务的Session共享

<br/>

<br/>

## 哈希Hash

#### 内部编码

哈希类型的内部编码有两种：

- ziplist压缩列表

- - 哈希类型元素个数小于512个，同时所有值都小于64字节时使用ziplist
  - ziplist使用紧凑结构实现多个元素的连续存储，在节省内存方面优秀，但操作时间长

- hashtable哈希表

- - 不满足ziplist条件时使用hashtable

<br/>

#### 使用场景

和字符串String基本相似。

<br/>

<br/>

## 列表List

#### 内部编码

列表类型的内部编码有两种（3.2版本之前）：

- ziplist压缩列表

- - 哈希类型元素个数小于512个，同时所有值都小于64字节时使用ziplist
  - ziplist使用紧凑结构实现多个元素的连续存储，在节省内存方面优秀，但操作时间长

- linkedlist链表

- - 不满足ziplist条件时使用linkedlist

列表类型的内部编码有两种（3.2版本之后）：

- 元素较少较小时使用ziplist
- 多则使用quicklist

**Quicklist**：

纯粹的使用 Linkedlist, 也就是普通链表来存储数据有两个弊端：

1. 每个节点都有自己的前后指针，指针所占用的内存有点多，太浪费了。
2. 每个节点单独的进行内存分配，当节点过多，造成的内存碎片太多了。影响内存管理的效率。

因此，定义了 quicklist, 将 linkedlist 和 ziplist 结合起来，形成一个 将多个 ziplist 通过前后指针互相连接起来的结构，可以在一定程度上缓解上面说到的两个问题。

<br/>

#### 使用场景

1. 消息队列
2. 文章列表

<br/>

<br/>

## 集合Set

#### 内部编码

集合类型的内部编码有两种：

- intset整数集合

- - 集合中元素都是整数，且个数小于512时使用intset

- hashtable哈希表

- - 不满足intset条件时使用hashtable

<br/>

#### 使用场景

1. 标签（用户兴趣标签等）

<br/>

<br/>

## 有序集合Zset

#### 内部编码

有序集合类型的内部编码有两种：

- ziplist压缩列表

- - 元素个数小于128个，同时所有值都小于64字节时使用ziplist

- skiplist跳跃表

- - 不满足ziplist条件时使用skiplist

<br/>

#### 使用场景

1. 排行榜（用户赞数等）