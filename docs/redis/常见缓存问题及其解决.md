缓存雪崩、穿透、击穿是每个学习缓存使用的人都应该熟知的问题。

**目录**

- [缓存雪崩](#缓存雪崩)
- [缓存穿透](#缓存穿透)
- [缓存击穿](#缓存击穿)

<br/>

<br/>

<br/>

## 缓存雪崩

#### 概念

缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

<br/>

#### 解决方案

- 在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值
- 如果**Redis**是集群部署，将热点数据均匀分布在不同的**Redis**库中也能避免全部失效的问题
- 设置热点数据永远不过期，有更新操作就更新缓存
- 选择合适的内存淘汰策略

<br/>

<br/>

## 缓存穿透

#### 概念

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

<br/>

#### 解决方案

- 添加参数校验，权限校验，对不合法情况进行过滤
- 如果有越过缓存直接访问数据库的请求，就为它添加值为null的key。但这样可能导致key过多
- 利用布隆过滤器（把数据库里有的数据添加到布隆过滤器里，请求数据库前先查过滤器看看有没有）

<br/>

<br/>

## 缓存击穿

#### 概念

**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，导致数据库崩掉。

<br/>

#### 解决方案

- 设置热点数据永不过期
- 也可以考虑对访问数据的代码块加上互斥锁（性能一般不太好）