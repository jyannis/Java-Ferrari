在上篇[IO（中）——深入理解JAVA层面的IO](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483980&idx=1&sn=1f7ae34cf2dc93b919b68dc5c90be443&chksm=9ffc602aa88be93c21fd2c298950e3c080d6a5384af906fd2f654209e61e9cee0a6a7667fce2&token=1958345249&lang=zh_CN#rd)中，我们认识了JAVA对于IO的封装：BIO、NIO、AIO。

而我们也知道，Java中提供的IO有关的API，在进行处理的时候，其实是依赖操作系统层面的IO操作实现的。

本篇文章中我们就继续探索下去，了解一下在Linux下的五种IO模型：

- 阻塞IO模型
- 非阻塞IO模型
- 多路复用IO模型
- 信号驱动IO模型
- 异步IO模型

> tips：
>
> 在下文中提到的“应用程序”、“用户进程”、“进程”普遍都指同一个概念。

<br/>

<br/>

## 阻塞IO模型

### 基本含义

和[IO（中）——深入理解JAVA层面的IO](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483980&idx=1&sn=1f7ae34cf2dc93b919b68dc5c90be443&chksm=9ffc602aa88be93c21fd2c298950e3c080d6a5384af906fd2f654209e61e9cee0a6a7667fce2&token=1958345249&lang=zh_CN#rd)中提到的BIO含义相似。

进程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。



### 操作流程

![阻塞IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/阻塞IO模型.png)

1. 应用程序通过系统调用`recv`或`recvfrom`尝试接收数据
2. 内核开始准备数据，其间应用程序**阻塞等待**
3. 内核准备好数据，并将数据从**内核空间**复制到**用户空间**
4. 应用程序处理数据

<br/>

> 阻塞IO模型下，应用程序可能耗费在等待上的时间过长，浪费了许多性能。
>
> 那么如何减少等待时间呢？就引入了非阻塞IO模型。

<br/>

<br/>

## 非阻塞IO模型

### 基本含义

与**阻塞IO模型**的不同之处在于，在非阻塞IO模型下，应用程序在等待数据时是采取**轮询**的方式，而不是**阻塞**的方式。

这就可以类比到JAVA里Synchronized悲观锁和CAS乐观锁的区别。

<br/>

### 操作流程

![非阻塞IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/非阻塞IO模型.png)

如果理解了前面的阻塞IO模型，对于现在这个非阻塞IO模型应该也很好理解。

应用程序轮询内核是否已准备好数据，直到准备好后对数据进行处理。

非阻塞的优势就在于，在连续两次轮询之间，应用程序可以去做一些别的事情。

<br/>

> 非阻塞IO模型下，应用程序耗费在等待上的时间少了一些。
>
> 但高频度的轮询，依然可能导致性能有比较大的损耗。
>
> 那能不能不由应用程序反复去问内核，而是由内核主动通知应用程序呢？
>
> 这就引入了信号驱动IO模型。

<br/>

<br/>

## 信号驱动IO模型

### 基本含义

信号驱动IO模型下，以通知而非轮询的方式完成数据的等待，然后再由应用程序完成对数据的处理。

<br/>

### 操作流程

![信号驱动IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/信号驱动IO模型.png)

1. 应用程序向内核注册一个信号处理程序

   注册是一个及时返回的操作，不会产生阻塞。

2. 内核准备好数据，对应用程序递交信号
3. 应用程序通过系统调用`recv`或`recvfrom`尝试接收数据
4. 内核将数据从内核空间复制到用户空间（期间应用程序阻塞）
5. 数据复制完成，应用程序开始处理数据

<br/>

> 信号驱动IO模型下，已经最大化节省了等待的时间。
>
> 但是由于需要引入信号，在实现复杂性上就会稍高一些。
>
> 事实上我们发现，还有更好的方式来提升性能，这就引入了下面的多路复用IO模型。

<br/>

<br/>

## 多路复用IO模型

### 基本含义

和[IO（中）——深入理解JAVA层面的IO](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483980&idx=1&sn=1f7ae34cf2dc93b919b68dc5c90be443&chksm=9ffc602aa88be93c21fd2c298950e3c080d6a5384af906fd2f654209e61e9cee0a6a7667fce2&token=1958345249&lang=zh_CN#rd)中提到的NIO含义相似。

多路复用IO模型下，多个应用程序（即多个进程）的IO注册到同一个管道里，由管道代替它们与内核交互。当内核准备好了任何一个应用程序的数据，就由管道通知应用程序去接收。

<br/>

### 操作流程

![多路复用IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/多路复用IO模型.png)

1. 应用程序注册到select上

   多个应用程序可以注册到同一个select

2. select阻塞，等待数据
3. 内核准备好了某个应用程序A的数据，select返回，通知应用程序
4. 应用程序通过系统调用`recv`或`recvfrom`尝试接收数据
5. 内核将数据从内核空间复制到用户空间（期间应用程序阻塞）
6. 数据复制完成，应用程序开始处理数据

<br/>

> 多路复用IO模型首先利用到了信号驱动的优势（select需要通知应用程序数据准备好了，所以也算是一种信号驱动）
>
> 另外，多路复用让一个select服务多个应用程序，采用一对多的方式，节省了一定的资源成本。
>
> 但是在数据复制（内核空间 → 用户空间）阶段，依然无法避免应用程序的阻塞。
>
> 为了优化数据复制时阻塞的问题，引入了下面的异步IO模型。

<br/>

<br/>

## 异步IO模型

### 基本含义

和[IO（中）——深入理解JAVA层面的IO](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483980&idx=1&sn=1f7ae34cf2dc93b919b68dc5c90be443&chksm=9ffc602aa88be93c21fd2c298950e3c080d6a5384af906fd2f654209e61e9cee0a6a7667fce2&token=1958345249&lang=zh_CN#rd)中提到的AIO含义相似。

在异步IO模型下，应用程序永远不会阻塞，发起IO请求之后就可以做自己的事情，直到数据准备且复制完成，再去处理数据。

<br/>

### 操作流程

![异步IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/异步IO模型.png)

1. 用户进程发起aio_read，开始做其他事情

2. 内核准备数据
3. 内核把数据从内核空间复制到用户空间
4. 内核通知用户进程数据已准备完毕
5. 用户进程开始处理数据

<br/>

> 多路复用IO模型首先利用到了信号驱动的优势（select需要通知应用程序数据准备好了，所以也算是一种信号驱动）
>
> 异步IO现在使用已愈趋广泛，但由于一些底层技术及框架的局限性，在很多应用领域还未能彻底替代多路复用IO。

<br/>

<br/>

## 五种IO模型的比较

最后我们来用一张图和一个表格来比较一下五种IO模型。

图源于网络，表格由我自行整理。

![五种IO模型](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/五种IO模型.jpg)

| IO模型     | 数据准备阶段 | 数据复制阶段 | 使用场景                                                     |
| ---------- | ------------ | ------------ | ------------------------------------------------------------ |
| 阻塞IO     | 阻塞         | 阻塞         | 连接少，IO任务简单的场景                                     |
| 非阻塞IO   | 非阻塞       | 阻塞         | 和阻塞IO差不多，比阻塞IO的能力强一些                         |
| 信号驱动IO | 非阻塞       | 阻塞         | 它性能没有复用IO和异步IO强，信号使用起来又复杂，一般不太使用 |
| 多路复用IO | 非阻塞       | 阻塞         | 连接多，IO任务简单的场景                                     |
| 异步IO     | 非阻塞       | 非阻塞       | 连接多，IO任务复杂的场景                                     |

