在上篇[IO（上）——基本概念](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483976&idx=1&sn=f6206aebd57292948b82cd38c8ac4071&chksm=9ffc602ea88be938b7f53337c48a1bab8b04242777f2867f443c604cc8278f592ec7b1f8df1d&token=2111105882&lang=zh_CN#rd)中，我们初步认识了同步异步、阻塞非阻塞的含义，并了解了与之对应的IO模型。

本篇文章中我们将这些基本概念具体化，探讨JAVA实现层面的IO。

在JAVA层面，我们需要熟悉的IO有三种：BIO，NIO，AIO。

本篇中，我们主要从“是什么”、“有什么用”、“怎么实现的”三个角度切入分析。

是什么——也即“基本概念”。

有什么用——也即“适用场景”。

有什么用——也即“基本原理”。

<br/>

<br/>

## BIO(Blocking I/O)

### 基本概念

同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。它是JDK4之前的唯一选择。

<br/>

### 使用场景

在连接数比较少的情况下，它还是很有用的，因为编码起来很方便，思路很简单清晰。

但是对于十万级百万级连接会有些吃力。

<br/>

### 基本原理

采用 **BIO 通信模型** 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。

我们通过自旋的方式监听请求，一旦接收到一个连接请求，就会建立通信套接字（Socket）进行读写。

此时不能再接收其他连接请求，只能等待同当前连接下的操作执行完成。

 不过可以通过多线程来支持多个客户端的连接，如下图所示。

![BIO基本原理](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/BIO%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)

如果要让 **BIO 通信模型** 能够同时处理多个请求，就必须使用多线程，也就是在接收到连接请求后为每个请求创建一个新的线程进行处理。

处理完成之后，通过输出流返回应答给客户端，线程销毁。

考虑到如果某个连接还没有释放，但又不做任何事情的话就会造成不必要的线程开销，因而可以通过 **线程池机制** 改善。传送门：[线程池知识总结](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483763&idx=1&sn=73501f177d4882a23401e614b7a06b5d&chksm=9ffc6315a88bea030635a6fc138fe4d41b10a2801c04f7eefdbe642b0317d5a9de98e627edef&scene=21#wechat_redirect)

<br/>

<br/>

## NIO(NEW I/O)

### 基本概念

JDK4开始支持。同步非阻塞I/O，表面上总体和BIO类似，但使用了多路复用技术，一个线程可以监听多个IO操作请求。



以下是一些分析性文本：

NIO是同步的多路复用IO。在上篇[IO（上）——基本概念](https://mp.weixin.qq.com/s?__biz=MzA4Mjk5OTA0OQ==&mid=2247483976&idx=1&sn=f6206aebd57292948b82cd38c8ac4071&chksm=9ffc602ea88be938b7f53337c48a1bab8b04242777f2867f443c604cc8278f592ec7b1f8df1d&token=2111105882&lang=zh_CN#rd)中，我们提到网上经常称NIO为Non-Blocking，也就是非阻塞IO，但是同步和非阻塞是无法同时满足的。那这到底是为什么呢？

这是因为NIO的非阻塞，指的是对于一个IO请求来看，是非阻塞的。NIO采取多路复用，一个线程可能会负责多个IO请求，在一个IO请求处理完后，线程并不会阻塞在哪里，而是可能去处理其他的IO请求。所以称之为非阻塞。

> tip：如果不了解IO多路复用，可能对上面这段话无法理解，请先继续看下去。

<br/>

### 使用场景

NIO适用于IO连接请求数目多但连接时间普遍较短的业务场景。

<br/>

### 基本原理

#### IO多路复用（multiplex）

我们先用通俗的话来讲一下多路复用是什么，这里借鉴一下知乎上不错的一篇回答（我有稍加修改）：

> 假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：
>
> \1. 第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。
>
> 这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。（诶个进行BIO）
>
> \2. 第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。（用三十个线程同时去做BIO）
>
> \3. 第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A……
>
> 这种就是IO多路复用。
>
> 
>
> 作者：柴小喵
> 链接：https://www.zhihu.com/question/28594409/answer/52835876

<br/>

#### NIO核心组件

NIO核心组件包括：Channel通道、Buffer缓冲、Selector选择器。利用这三个核心组件，构成新IO的强大优势。

- Channel
- Buffer
- Selector

<br/>

##### 通道（Channel）

NIO 通过Channel（通道） 进行读写。

就好像流操作都要基于Stream一样，NIO中的所有I/O操作都基于Channel对象。

一个Channel代表和某一实体（文件、网络套接字Socket等）的连接。

通过Channel，可以读取数据到Buffer中，也可以把Buffer中的数据写入通道。

| **区别**           | **Stream**     | **Channel**                                      |
| ------------------ | -------------- | ------------------------------------------------ |
| 支持异步           | 不支持         | 支持                                             |
| 是否可双向传输数据 | 不能，只能单向 | 可以，既可以从通道读取数据，也可以向通道写入数据 |
| 是否结合Buffer使用 | 不             | 必须结合Buffer使用                               |
| 性能               | 较低           | 较高                                             |

<br/>

##### 缓冲（Buffer）

NIO中所使用的缓冲区是封装过的Buffer类，而不是简单的byte数组等等。

借助Buffer提供的API，我们可以灵活地操作数据。

**Buffer本质上就是一块内存区**，可以用来写入数据，并在稍后读取出来。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中，可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。

最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer，还有其他的一些缓冲区。每一种Java基本类型（除了Boolean）都对应有一种缓冲区。

<br/>

##### 选择器（Selector）

NIO的IO多路复用是利用选择器实现的，它是Java NIO核心组件之一。

Selector用于采集各个Channel的状态（或者说事件）。

我们将多个Channel注册到Selector中，由一个线程进行监听，当事件触发时再进行处理，以实现IO多路复用。

这些事件包含：

- Accept：有可接受的连接
- Connect：连接成功
- Read：有数据可读
- Write：可以写入数据

![Selector](https://gitee.com/jyannis/JavaLearning/raw/master/docs/IO/docs/Selector.png)

<br/>

<br/>

## AIO(Asynchronous I/O)

### 基本概念

JDK7开始支持。异步I/O，基于事件和回调机制实现。

<br/>

### 使用场景

AIO适用于IO连接请求数目多且连接时间往往较长的业务场景。

<br/>

### 基本原理

JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO。

在JAVA AIO框架中，由于应用程序不是轮询方式，而是事件触发和回调的方式，所以不再需要选择器（Selector）了，改由通道（Channel）直接到操作系统注册监听。

JAVA NIO和JAVA AIO框架，除了因为操作系统的实现不一样而去掉了Selector外，其他的重要概念都是存在的，例如上文中提到的Channel的概念，还有基于Buffer缓冲处理。